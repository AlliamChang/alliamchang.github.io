---
title: 编译原理 之 词法分析
date: 2020-09-08 16:04:41
tags:
- 编译原理
categories:
- 学习笔记
---
编译原理是计算机专业的一门重要专业课，旨在介绍编译程序构造的一般原理和基本方法。内容包括语言和文法、词法分析、词法分析、词法制导翻译、中间代码生成、存储管理、代码优化和目标代码生成。
<!-- more -->
# 前言
上面是摘于百度百科对编译原理的介绍。编译原理是我大三时候的一门课程，当时这门课的任课老师是由东南大学过来的老师——翟玉庆，他诙谐的语调以及常挂在嘴边的口头禅("实实在在的")是对他最深刻的印象。翟老师的授课也是"实实在在的"，相比于我南的其他老师真是超出多少条街，每一份交上去的作业都会认真地手写批改。所以编译原理这门课应该是我大三一年里上的最认真的一门课，也是成绩最高的。课程的2次实验作业，我也都是提前做完的(一般我都是ddl驱动。。) 这是我最自豪的作业之一了。
可惜几年过去了，由于平时开发并不会有接触编译原理的机会，渐渐就忘记了大部分的内容。最近面试的时候，有面试官问到的时候，我完全答不上来，真是有点对不起翟老师。所以决定再拾起来，重新跟着实验再复习一遍编译原理。

# 词法分析器
**词法分析**（英语：lexical analysis）是计算机科学中将字符序列转换为单词（Token）序列的过程。进行词法分析的程序或者函数叫作**词法分析器**（Lexical analyzer，简称Lexer），也叫扫描器（Scanner）。词法分析器一般以函数的形式存在，供语法分析器调用。 完成词法分析任务的程序称为词法分析程序或词法分析器或扫描器。 
完成词法分析任务的程序称为词法分析程序或词法分析器或扫描器。从左至右地对源程序进行扫描，按照语言的词法规则识别各类单词，并产生相应单词的属性字。(同样摘于百度百科XD)
编译原理课上的实验作业是基于**Lex**语法构造的词法分析器。构造词法分析器的主要原理是将每一个词法规则，即正则表达式，转换成一个有限自动状态机，再将一系列的状态机合并成一个最终的状态机，而这个状态机就是我们要的词法分析器。

## RE -> NFA
首先，需要识别出用户定义的词法规则，例如`[0-9]`就代表着普通的数字，`[0-9]+`代表着常见的int类型，而`if/else/while/for`这些关键字自身就是一个正则。这些正则式都是人们习惯于使用来表示字符串的匹配模式，机器是难以识别的这些模式的，而状态机才是机器更合适的识别工具，所以，先要将这些正则式转变成 **非确定有限状态机(NFA)** ——事实上，这两种表述形式本质上都对应着相同的语言，即正则语言。
在这里我们用到了**Thompson算法**来构造非确定有限状态机。

### Thompson算法
**Thompson算法**通过递归地将一个正则表达式划分成构成它的子表达式，在得到每个子表达式对应的NFA之后，根据子表达式之间的运算关系和一系列规则构造表达式自身对应的NFA。具体来说，这套算法细分成5种构造规则(a, b可以表示任意的表达式)：

* e -> ε (空表达式)
![空表达式](/image/lexical_analysis/nothing.png)

* e -> a (单符号表达式)
![单符号表达式](/image/lexical_analysis/single.png)

* e -> ab (连接表达式)
![连接表达式](/image/lexical_analysis/connect.png)
f(a)的初态成为新的NFA的初态。 原来f(a)的终态成为f(b)的初态。而原来f(b)的终态成为新的NFA的终态。

* e -> a|b (选择表达式)
![选择表达式](/image/lexical_analysis/select.png)
通过ε转移， 初始态0可以直接到达f(a)或f(b)的初态。而f(a)或f(b)原来的终态也可以通过ε转移直接到达整个NFA的新终态

* e -> a* (闭包表达式)
![闭包表达式](/image/lexical_analysis/closure.png)
将新表达式的初态和终态以及夹在中间的子表达式f(a)三者连接起来的ε转移使得可以选择经过或者不经过子表达式。而从f(a)的终态到初态的ε转移使得e可以重复任意多次。

除了上述的表达式，还有括号表达式`(e)`，直接视为`e`处理即可。这些表达式之间有构造的优先级：括号 > 闭包 > 连接 > 选择。递归构造时，需要从低优先级往高优先级构造。下面是利用**Thompson算法**规则对`a(b|c)*`正则式进行构造：

根据优先级，
1. 构造a
![step1](/image/lexical_analysis/step1.png)

2. 构造af(x)，x = (b|c)*
![step2](/image/lexical_analysis/step2.png)

3. 构造f(y)*，y = b|c
![step3](/image/lexical_analysis/step3.png)

4. 构造b|c
![step4](/image/lexical_analysis/step4.png)

## NFA -> DFA
现在，我们已经得到了一个可以被机器识别的状态机，但是这个状态机的是不确定的，像是上面的`a(b|c)*`构造出来的DFA，状态2可以通过空边转移到状态3，也可以通过空边转移到终态5。后继状态的不确定性，以及NFA允许有多个初态，使得NFA的识别速度会很慢。所以我们需要一个确定的无二义性的有限状态机(DFA)，DFA满足：1. 初态唯一；2. 一个状态对于某个字符，最多只有一条出边；3. 无空边(ε)。可以说DFA就是NFA的一个特例。
将NFA转换为DFA，需要用到**ε-edge闭包算法**：

### 算法思路
1. ε-closure(q) 从状态q出发，只经ε转换能到达的所有状态的集合，其中：
    1. q∈ε-closure(q)
    2. 从q出发经任意条ε弧而能到达的任何状态q’∈ε-closure(q) 
2. ε-closure(I) = {q’|q’∈ε-closure(q) & q∈I}
3. Ia=ε-closure(J) a∈∑，其中J为从I中任一状态出发经输入符号a所能到达状态结点的全体。


1. I0=ε-closure(0), add 0 to S’(状态集)
2. 从S’中选择一个状态I，对于任意符号a∈Σ
    1. 让S’=ε-closure(NextStates(S,a))
    2. add(S,a) → S’ to Φ’
    3. 如果 S’∉SS’ 添加状态S’到SS’
3. 重复上述步骤直到所有的状态都处理过（无新状态）
4. 对于一个状态S在SS’ S={S1,…,Sn},如果存在Si∈TS 则S是一个接受状态在A’中，添加S进TS’

### 例子
下面以正则式`(a|b)*(aa|bb)(a|b)*`为例
![NFA](/image/lexical_analysis/NFA.png)
```
# 使用ε-edge闭包算法构造过程
I0=ε-closure({0})={0,1,2}

ε-closure(Move(I0,a))=ε-closure({1,3})={1,3,2}=I1
ε-closure(Move(I0,b))=ε-closure({1,4})={1,4,2}=I2

ε-closure(Move(I1,a))=ε-closure({1,3,5})={1,2,3,5,6,7}=I3
ε-closure(Move(I1,b))=ε-closure({1,4})={1,4,2}=I2

ε-closure(Move(I2,a))=ε-closure({1,3})={1,3,2}=I1
ε-closure(Move(I2,b))=ε-closure({1,4,5})={1,2,4,5,6,7}=I4

ε-closure(Move(I3,a))=ε-closure({1,3,5,6})={1,2,3,5,6,7}=I3
ε-closure(Move(I3,b))=ε-closure({1,4,6})={1,2,4,6,7}=I5

ε-closure(Move(I4,a))=ε-closure({1,3,6})={1,2,3,6,7}=I6
ε-closure(Move(I4,b))=ε-closure({1,4,5,6})={1,2,4,5,6,7}=I4

ε-closure(Move(I5,a))={1,2,3,6,7}=I6
ε-closure(Move(I5,b))={1,2,4,5,6,7}=I4

ε-closure(Move(I6,a))={1,2,3,5,6,7}=I3
ε-closure(Move(I6,b))={1,2,3,5,6,7}=I5
```

构造完成后，我们可以列出状态机的转换表格，其中还有终态7的都是新的终态(I3, I4, I5, I6)

| I  | a  | b  |
|:---------:|:---------:|:---------:|
| I0 | I1 | I2 |
| I1 | I3 | I2 |
| I2 | I1 | I4 |
| I3 | I3 | I5 |
| I4 | I6 | I4 |
| I5 | I6 | I4 |
| I6 | I3 | I5 |

结果：
![DFA](https://img9.doubanio.com/view/photo/l/public/p2619823525.webp)

## 最小化DFA
得到了DFA，我们就可以输入字符序列，输出单词(Token)序列，到这一步我们已经完成了整个有限状态机的构造。不过，由**ε-edge闭包算法**得出的DFA会存在大量的新状态，这就导致状态机占用空间太大。因此我们可以对DFA进行**最小化**。

### 状态的等价性
假设s和t为M的两个状态
1. 若分别从状态s和状态t出发都能读出某个字α而停止于终态，则称s和t等价
2. 存在一个字α，使得s和t一个读出α停止于终态，另一个读出α停止于非终态，则称s和t可区别

### 基本思想
1. 把M的状态集分为一些不相交的子集，使任何两个不同子集状态是可区别的，而同一子集的任何两个状态是等价的
2. 让每个子集选出一个代表，同时消去其他状态

### 划分
1. 把S划分为终态和非终态两个子集，形成基本划分∏
2. 假定某个时候∏已含m个子集，记为∏={I(1),I(2),…,I(m)},检查∏中的每个子集能否进一步划分：
    1. 假定s1和s2是I(i)={s1,s2,…sk}中的两个状态，它们经过a弧分别到达t1和t2,而t1和t2属于现行∏中的两个不同子集，则s1和s2不等价
    2. 一般地，对于某个I(i),若Ia(i)落于现行∏中N个不同的子集，则应把I(i)划分成N个不相交的组
3. 重复步骤2，直至没有新的分组出现 

### 例子
以上面生成的DFA为例子
![DFA](https://img9.doubanio.com/view/photo/l/public/p2619823525.webp)

1. 将上图状态分为两个子集：非终态集s0={3, 4, 5, 6}，终态集s1={0, 1, 2}
2. s1中，所有状态的转移都是在子集中的，所以不需要再进一步划分
3. s0中，状态1和2存在到达终态的转移，而状态0没有，因此进一步划分为s2={0}，s3={1, 2}
4. s3中，状态1是经过字符a到达终态的，而状态2是经过字符b到达，两者不等价，再拆分为s4={1}，s5={2}
5. 到此所有的子集已不能再拆分，结束算法

下面就是最小化之后得到的DFA图

![最小化DFA](/image/lexical_analysis/minDFA.png)


# git源码
https://github.com/AlliamChang/Lex